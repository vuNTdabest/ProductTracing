const EC = require("elliptic").ec;
const ec = new EC("secp256k1");
const fs = require("fs");
const TransactionClass = require("./transaction");
const Transaction = new TransactionClass();
const path = require("path");

class Wallet {
  constructor(wallet) {
    this.walletId = wallet.walletId;
    this.balance = wallet.balance;
    this.privateKey = wallet.privateKey;
    this.publicKey = wallet.publicKey;
  }

  toString() {
    return `Wallet -
      publicKey: ${this.publicKey.toString()}
      balance  : ${this.balance}`;
  }

  sign(dataHash) {
    const keyPair = ec.keyFromPrivate(this.privateKey, "hex");
    return keyPair.sign(dataHash);
  }

  createTransaction(
    recipient,
    amount,
    transactionPool,
    blockchain,
    type,
    data
  ) {
    this.balance = this.calculateBalance(blockchain);

    if (amount > this.balance) {
      console.log(
        24,
        `Amount ${amount} exceeds the current balance ${this.balance}`
      );
      return;
    }

    var transaction = transactionPool.existingTransaction(this.publicKey);

    if (transaction) {
      transaction.update(this, recipient, amount, type, data);
    } else {
      transaction = Transaction.newTransaction(
        this,
        recipient,
        amount,
        type,
        data
      );
      transactionPool.updateOrAddTransaction(transaction);
    }
    const file = "../backup/PendingList.txt";
    fs.writeFile(file, JSON.stringify(transactionPool.transactions), function(
      err
    ) {
      if (err) {
        return console.error(err);
      }
      console.log(65, "store pendingList successfully!");
    });
    return transaction;
  }

  /**
   * updates the balance of the wallet
   * based on the latest transaction
   */

  calculateBalance(blockchain) {

    console.log(106, blockchain.chain.length);

    // store the existing balance
    let balance = this.balance;

    // create an array of transactions
    let transactions = [];

    // store all the transactions in the array
    blockchain.chain.forEach(block =>
      block.data.forEach(transaction => {
        transactions.push(transaction);
      })
    );

    // get all the transactions generated by the wallet ie money sent by the wallet
    const walletInputTransactions = transactions.filter(
      transaction => transaction.input.address === this.publicKey
    );

    // declare a variable to save the timestamp
    let startTime = 0;

    if (walletInputTransactions.length > 0) {
      // get the latest transaction
      const recentInputTransaction = walletInputTransactions.reduce(
        (prev, current) =>
          prev.input.timestamp > current.input.timestamp ? prev : current
      );

      // get the outputs of that transactions, its amount will be the money that we would get back
      balance = recentInputTransaction.outputs.find(
        output => output.address === this.publicKey
      ).amount;

      // save the timestamp of the latest transaction made by the wallet
      startTime = recentInputTransaction.input.timestamp;
    }

    // get the transactions that were addressed to this wallet ie somebody sent some moeny
    // and add its ouputs.
    // since we save the timestamp we would only add the outputs of the transactions recieved
    // only after the latest transactions made by us

    transactions.forEach(transaction => {
      if (transaction.input.timestamp > startTime) {
        transaction.outputs.find(output => {
          if (output.address === this.publicKey) {
            balance += Number(output.amount);
          }
        });
      }
    });
    return balance;
  }

  calculateBalanceAvailable(transactionPool) {
    let time = 0;
    let transactions = transactionPool.transactions;

    const walletInputTransactions = transactions.filter(
      transaction => transaction.input.address === this.publicKey
    );

    if (walletInputTransactions.length > 0) {
      const recentInputTransaction = walletInputTransactions.reduce(
        (prev, current) =>
          prev.input.timestamp > current.input.timestamp ? prev : current
      );
      this.balance = recentInputTransaction.outputs.find(
        output => output.address === this.publicKey
      ).amount;
      time = recentInputTransaction.input.timestamp;
    }

    transactions.forEach(transaction => {
      if (transaction.input.timestamp > time) {
        transaction.outputs.find(output => {
          if (output.address === this.publicKey) {
            this.balance = Number(this.balance) + Number(output.amount);
          }
        });
      }
    });
    return this.balance;
  }
}
module.exports = Wallet;
